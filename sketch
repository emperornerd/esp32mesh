#include <WiFi.h>
#include <esp_now.h>

#define USE_DISPLAY true
#if USE_DISPLAY
  #include <TFT_eSPI.h>
  TFT_eSPI tft = TFT_eSPI();
  bool displayActive = false;
  String lastShown = "";
#endif

// Trusted MAC addresses
const uint8_t trustedMACs[][6] = {
  {0x08, 0xA6, 0xF7, 0x47, 0xFA, 0xAD},
  {0x14, 0x33, 0x5C, 0x6D, 0x74, 0x04}
};
const int numTrusted = sizeof(trustedMACs) / sizeof(trustedMACs[0]);

const char* ssid = "ProtestInfo";
WiFiServer server(80);
IPAddress IP;
String MAC;
String serialBuffer = "";

unsigned long lastUpdate = 0;
int counter = 1;

// Format MAC as string
String formatMac(const uint8_t *mac) {
  char buf[18];
  snprintf(buf, sizeof(buf), "%02X:%02X:%02X:%02X:%02X:%02X",
           mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  return String(buf);
}

// Check MAC trust
bool isTrustedMAC(const uint8_t *mac) {
  for (int i = 0; i < numTrusted; i++) {
    if (memcmp(mac, trustedMACs[i], 6) == 0) return true;
  }
  return false;
}

// Handle incoming ESP-NOW
void onDataRecv(const esp_now_recv_info *recvInfo, const uint8_t *data, int len) {
  if (len <= 0 || len > 250 || !isTrustedMAC(recvInfo->src_addr)) return;

  String incoming;
  for (int i = 0; i < len; i++) incoming += (char)data[i];
  incoming.trim();

  if (serialBuffer.indexOf(incoming) == -1) {
    serialBuffer += incoming + "\n";
    if (serialBuffer.length() > 1000)
      serialBuffer = serialBuffer.substring(serialBuffer.length() - 1000);
    Serial.println("ðŸ“¥ " + incoming);

#if USE_DISPLAY
    if (displayActive) {
      int breakPos = serialBuffer.lastIndexOf('\n', serialBuffer.length() - 2);
      String latest = serialBuffer.substring(breakPos + 1);
      if (latest != lastShown) {
        tft.fillScreen(TFT_BLACK);
        tft.setCursor(0, 0);
        tft.setTextColor(TFT_CYAN);   tft.println("MAC: " + MAC);
        tft.setTextColor(TFT_GREEN);  tft.println("IP: " + IP.toString());
        tft.setTextColor(TFT_WHITE);
        tft.println("----------------------");
        tft.println("Latest Msg:");
        tft.println(latest);
        lastShown = latest;
      }
    }
#endif
  }
}

// Broadcast to peers
void sendToAllPeers(const String &message) {
  for (int i = 0; i < numTrusted; i++) {
    esp_err_t result = esp_now_send(trustedMACs[i], (uint8_t*)message.c_str(), message.length());
    if (result != ESP_OK)
      Serial.printf("âŒ Send to %s failed (err %d)\n", formatMac(trustedMACs[i]).c_str(), result);
  }
}

void setup() {
  Serial.begin(115200);
  WiFi.mode(WIFI_AP);
  WiFi.softAP(ssid, nullptr, 1);  // Fixed channel 1 for mesh
  IP = WiFi.softAPIP();
  MAC = WiFi.softAPmacAddress();
  server.begin();

#if USE_DISPLAY
  tft.begin();
  tft.setRotation(1);
  tft.fillScreen(TFT_BLACK);
  tft.setTextColor(TFT_YELLOW, TFT_BLACK);
  tft.setTextSize(1);
  tft.setCursor(0, 0);
  tft.println("Starting node...");
  displayActive = true;
  Serial.println("âœ… Display initialized");
#endif

  if (esp_now_init() != ESP_OK) {
    Serial.println("âŒ ESP-NOW init failed");
    return;
  }

  for (int i = 0; i < numTrusted; i++) {
    esp_now_del_peer(trustedMACs[i]);  // Clean start
    esp_now_peer_info_t peer{};
    memcpy(peer.peer_addr, trustedMACs[i], 6);
    peer.channel = 1;
    peer.encrypt = false;
    esp_err_t result = esp_now_add_peer(&peer);
    if (result == ESP_OK)
      Serial.println("âœ… Peer added: " + formatMac(trustedMACs[i]));
    else
      Serial.printf("âŒ Failed to add peer %s (err %d)\n", formatMac(trustedMACs[i]).c_str(), result);
  }

  esp_now_register_recv_cb(onDataRecv);
}

void loop() {
  if (millis() - lastUpdate >= 5000) {
    lastUpdate = millis();
    char messageID[9];
    snprintf(messageID, sizeof(messageID), "%08X", esp_random());

    char msg[128];
    snprintf(msg, sizeof(msg), "[%s] %s - \"Message %d\"", messageID, MAC.c_str(), counter);

    if (serialBuffer.indexOf("[" + String(messageID) + "]") == -1) {
      serialBuffer += msg;
      serialBuffer += "\n";
      Serial.println("ðŸ“¡ " + String(msg));
      counter++;

      if (serialBuffer.length() > 1000)
        serialBuffer = serialBuffer.substring(serialBuffer.length() - 1000);

      sendToAllPeers(msg);

#if USE_DISPLAY
      if (displayActive) {
        tft.fillScreen(TFT_BLACK);
        tft.setCursor(0, 0);
        tft.setTextColor(TFT_CYAN);   tft.println("MAC: " + MAC);
        tft.setTextColor(TFT_GREEN);  tft.println("IP: " + IP.toString());
        tft.setTextColor(TFT_WHITE);
        tft.println("----------------------");
        tft.println("Latest Msg:");
        tft.println(msg);
        lastShown = msg;
      }
#endif
    }
  }

  WiFiClient client = server.available();
  if (client) {
    String currentLine;
    while (client.connected()) {
      if (client.available()) {
        char c = client.read();
        if (c == '\n' && currentLine.length() == 0) {
          client.println(F("HTTP/1.1 200 OK"));
          client.println(F("Content-type:text/html"));
          client.println(F("Connection: close"));
          client.println();

          client.println(F("<!DOCTYPE html><html><head><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">"));
          client.println(F("<style>html{font-family:Helvetica;text-align:center;margin:20px;}pre{background:#f4f4f4;padding:10px;border-radius:5px;text-align:left;max-width:600px;margin:0 auto;}</style></head><body>"));
          client.println(F("<h1>Protest Information</h1>"));
          client.println(F("<p>This is updated via a meshnet, and information may be delayed.</p>"));
          client.printf("<p><strong>Base Station IP:</strong> %s</p>", IP.toString().c_str());
          client.printf("<p><strong>MAC Address:</strong> %s</p>", MAC.c_str());
          client.println(F("<h2>Serial Data:</h2><pre>"));
          client.print(serialBuffer);
          client.println(F("</pre></body></html>"));
          break;
        } else if (c != '\r') {
          currentLine += c;
        } else {
          currentLine = "";
        }
      }
    }
    client.stop();
  }
}
